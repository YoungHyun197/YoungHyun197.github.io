---
title : "Pytorch CIFAR10 모델"
category :
    - pytorch
tag :
    - pytorch
    - deep-learning
    - machine-learning
toc : true
toc_sticky: true
comments: true
---
CIFAR10 모델에 대하여 알아보자 

# Modules import

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader

import torchvision
import torchvision.datasets
import torchvision.transforms as transforms

import numpy as np
import matplotlib.pyplot as plt
plt.style.use('seaborn-white')
```

- 현재 GPU 설정

```python
torch.cuda.is_available()

use_cuda = torch.cuda.is_available()
device = torch.device("cuda" if use_cuda else "cpu")

device
```

# 전처리 설정

```python
transform = transforms.Compose([transforms.ToTensor(),
                               transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])
```

# 데이터 로드 및 확인

```python
trainset = torchvision.datasets.CIFAR10(root='/data',
                                        train=True,
                                        download = True,
                                        transform=transform)

testset = torchvision.datasets.CIFAR10(root='/data',
                                        train=False,
                                        download = True,
                                        transform=transform)
```

``` python
classes = ('plane', 'car', 'bird', 'cat', 'deer',
           'dog', 'frog', 'horse', 'ship', 'truck')

def imshow(img):
  img = img / 2 + 0.5 # 이미지 unnormalize
  npimg = img.numpy() # 이미지를 넘파이 형태로 변환 
  plt.imshow(np.transpose(npimg, (1, 2, 0))) # 기존의 파이토치텐서와 구조가 다르므로 transpose
  plt.show()

dataiter = iter(train_loader)
images, labels = dataiter.next()

imshow(torchvision.utils.make_grid(images))
print(''.join('{}\t'.format(classes[labels[j]]) for j in range(4)))
```

# 신경망 구성

```python
class Net(nn.Module):
  def __init__(self):
    super(Net, self).__init__()

    self.conv1 = nn.Conv2d(3, 6, 5)
    self.pool = nn.MaxPool2d(2,2)
    self.conv2 = nn.Conv2d(6,16,5)
    self.fc1 = nn.Linear(16 * 5 * 5, 120)
    self.fc2 = nn.Linear(120, 84)
    self.fc3 = nn.Linear(84, 10)

  def forward(self, x):
    x = self.pool(F.relu(self.conv1(x)))
    x = self.pool(F.relu(self.conv2(x)))
    x = x.view(-1, 16*5*5)
    x = F.relu(self.fc1(x))
    x = F.relu(self.fc2(x))
    x = self.fc3(x)

    return x

net = Net().to(device)
```

# 손실함수와 옵티마이저

```python
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr = 0.001, momentum=0.9)

```

# 모델 학습
- epoch = 10으로 설정

```python
for epoch in range(10):
  running_loss = 0.0

  for i, data in enumerate(train_loader, 0):
    inputs, labels = data[0].to(device), data[1].to(device)

    optimizer.zero_grad()

    outputs = net(inputs)
    loss = criterion(outputs, labels)
    loss.backward()
    optimizer.step()

    running_loss += loss.item()
    if i % 2000 == 1999:
      print("Epoch: {}, Batch: {}, Loss: {}".format(epoch+1, i+1, running_loss/2000))
      running_loss = 0.0 

```
#  모델의 저장 및 로드

```python
PATH = './cifar_net.pth'
torch.save(net.state_dict(), PATH)
```

```python
dataiter = iter(test_loader)
images, labels = dataiter.next()

imshow(torchvision.utils.make_grid(images))
print(''.join('\t{}'.format(classes[labels[j]]) for j in range(4)))

net = Net().to(device)
net.load_state_dict(torch.load(PATH))
```
# 모델 테스트

```python
outputs = net(images.to(device))

_, predicted = torch.max(outputs, 1)
print(' '.join('\t{}'.format(classes[predicted[j]]) for j in range(4)))

```

```python
correct = 0
total = 0

with torch.no_grad():
  for data in test_loader:
    images, lables = data[0].to(device), data[1].to(device)
    outputs = net(images)
    _, predicted = torch.max(outputs.data, 1) # 제일 높은 확률 1개만 가져오기
    total += labels.size(0)
    correct += (predicted.to('cpu') == labels).sum().item()

print(100 * correct / total)

```

```python
class_correct = list(0. for i in range(10))
class_total = list(0. for i in range(10))

with torch.no_grad():
  for data in test_loader:
    images, labels = data[0].to(device), data[1].to(device)
    outputs = net(images.to(device))
    _, predicted = torch.max(outputs.data, 1)
    c = (predicted.to(device) == labels.to(device)).squeeze()
    for i in range(4):
      label = labels[i]
      class_correct[label] += c[i].item()
      class_total[label] += 1

  for i in range(10):
    print("Accuracy of {}: {}%".format(classes[i], 100 * class_correct[i] / class_total[i]))    

```

![](/assets/image/2022-03-14-15-54-35.png)